# -*- coding: utf-8 -*-
"""NASP_lab_Wikipedia_PageViews.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1h02CKZegKW3Gj0IKCdXs11oMVWOGjKRK
"""

# Možeš lokalno da ubaciš dataset (ako ga skineš kod sebe)
from google.colab import files
uploaded = files.upload()

# Povezivanje da ti pronađe dataset preko drive-a
from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import csv

filename = "/content/wikipedia-pageviews-20240101"

df = pd.read_csv(
    filename,
    sep=r"\s+",                 # bilo koji whitespace
    header=None,
    names=["project", "title", "views", "bytes"],
    engine="python",
    quoting=csv.QUOTE_NONE,     # ignoriši navodnike
    encoding="utf-8",
    on_bad_lines="skip"         # ako je neki red baš pokvaren, preskoči ga
)

print(df.head())
print(df.shape)

df.shape

print("Ukupan broj redova:", len(df))

df['project'].unique()

df['project'].value_counts()

df['project'].value_counts().head(20)

mask_en = df['project'].map(lambda x: x[:2] == 'en')
df.loc[mask_en, 'project'].value_counts()

df[df['project'].isin(["en", "en.m"])].shape

#Spajanje u jedan dataset podataka proj en i en.m
valid_projects = ["en", "en.m"]
df_en = df[df['project'].isin(valid_projects)]

# Spajanje u jedan red dupliciranih istih pod koji su se tražili i preko en i en_m
df_en_merged = (
    df_en
    .groupby("title", as_index=False)
    .agg({
        "views": "sum",
        "bytes": "sum"   # možeš i izbaciti ako ti bytes ne trebaju
    })
)

df_en_merged["project"] = "en_merged"

df_en_merged = df_en_merged[["project", "title", "views", "bytes"]]

print("Broj redova prije spajanja:", len(df_en))
print("Broj redova poslije spajanja:", len(df_en_merged))

# pravljenje liste sa svim podacima naslova jedan iza drugog onoliko puta koliko su se tražili
import numpy as np

access_sequence = np.repeat(
    df_en_merged["title"].values,
    df_en_merged["views"].values
)

len(access_sequence)

# Exportujemo niz
with open("access_sequence.txt", "w") as f:
    for item in access_sequence:
        f.write(item + "\n")

import os
os.listdir('/content')

# Pravimo novi niz - samo one stranice koje imaju bar 50 pregleda
df_small = df_en_merged[df_en_merged["views"] >= 50].copy()

import numpy as np
access_sequence_small = np.repeat(
    df_small["title"].values,
    df_small["views"].values
)

len(access_sequence_small)

# Exportujemo niz
with open("access_sequence_small.txt", "w") as f:
    for item in access_sequence_small:
        f.write(item + "\n")

import os
os.listdir('/content')

seq_test = access_sequence_small[:200_000]
len(seq_test)

# Implementacija Move-To-Front u Pythonu
import numpy as np

def move_to_front(access_sequence):
    """
    access_sequence: niz pristupa (npr. access_sequence_small)

    Vraća:
      - final_list: stanje liste nakon svih pristupa
      - total_cost: ukupan trošak pristupa
      - access_costs: lista troškova po pristupu
    """
    # početno stanje liste: elementi redom kako se prvi put pojave
    current_list = []
    seen = set()
    for item in access_sequence:
        if item not in seen:
            seen.add(item)
            current_list.append(item)

    total_cost = 0
    access_costs = []

    for key in access_sequence:
        # pronađi poziciju (linearna pretraga, kao u jednostavnoj listi)
        idx = current_list.index(key)      # O(n)
        cost = idx + 1                     # pozicija + 1
        total_cost += cost
        access_costs.append(cost)

        # pomjeri element na početak (front)
        if idx != 0:
            current_list.pop(idx)
            current_list.insert(0, key)

    return current_list, total_cost, access_costs

# poziv i rezultati

final_list_mtf, total_cost_mtf, access_costs_mtf = move_to_front(seq_test)

print("Broj pristupa:", len(seq_test))
print("Ukupan trošak (MTF):", total_cost_mtf)
print("Prosječni trošak po pristupu:", total_cost_mtf / len(seq_test))

# Implementacija Count u Pythonu

# Implementacija Count heuristike u Pythonu

def count_algorithm(access_sequence):

    # početno stanje liste: elementi redom kako se prvi put pojave
    current_list = []
    counts = []          # paralelni niz koji čuva count za svaki element

    total_cost = 0
    access_costs = []

    for key in access_sequence:
        # provjera da li je element već u listi
        if key in current_list:
            idx = current_list.index(key)
        else:
            # novi element – dodaj ga na kraj liste sa početnim brojem pristupa 0
            current_list.append(key)
            counts.append(0)
            idx = len(current_list) - 1

        # trošak pristupa je pozicija + 1
        cost = idx + 1
        total_cost += cost
        access_costs.append(cost)

        # uvećaj broj pristupa za ovaj element
        counts[idx] += 1

        # "bubble up": pomjeraj element prema početku liste
        # sve dok ima veći count od elemenata ispred sebe
        while idx > 0 and counts[idx] > counts[idx - 1]:
            # zamijeni mjesta u oba niza (i ključ i njegov count)
            counts[idx], counts[idx - 1] = counts[idx - 1], counts[idx]
            current_list[idx], current_list[idx - 1] = current_list[idx - 1], current_list[idx]
            idx -= 1

    return current_list, counts, total_cost, access_costs

final_list_count, counts_count, total_cost_count, access_costs_count = count_algorithm(seq_test)

print("=== REZULTATI – COUNT HEURISTIKA ===")
print("Broj pristupa:", len(seq_test))
print("Ukupan trošak (COUNT):", total_cost_count)
print("Prosječni trošak po pristupu (COUNT):", total_cost_count / len(seq_test))

print("=== POREĐENJE MTF vs COUNT ===")
print("Ukupan trošak (MTF):   ", total_cost_mtf)
print("Ukupan trošak (COUNT): ", total_cost_count)
print("Prosječni trošak (MTF):   ", total_cost_mtf / len(seq_test))
print("Prosječni trošak (COUNT): ", total_cost_count / len(seq_test))